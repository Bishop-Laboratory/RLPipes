import snakemake as snk
import json
import shutil
import os
import io
from contextlib import redirect_stdout
import sys


def make_snakes(config_files, run_path, dryrun=False, dag=False, force=False):
    """Python wrapper for snakemake api + log_handler function in RSeq

    :param run_path: path where run data is stored independent of files generated by snakemake
    :param dryrun: bool indicating whether to execute a snakemake dry run
    :param dag: bool indicating whether to generate the DAG
    :param force: bool if true, snakemake will re-run the whole workflow
    :param config_files: list of snakemake config files in .json format
    :return: None
    """

    if dryrun:
        print("Dry run")
        log_folder_all = run_path + '/logs-dryrun/'
    elif dag:
        print("Dag run")
        log_folder_all = run_path + '/logs-dag/'
    else:
        log_folder_all = run_path + '/logs/'

    if os.path.isdir(log_folder_all):
        shutil.rmtree(log_folder_all)
    os.makedirs(log_folder_all)

    for config_file in config_files:

        config = json.load(open(config_file))
        if not dryrun and not dag:
            # Unlock any previous runs TODO: this should be removed probably... We need unique dirs for multiple runs!
            snk.snakemake('rseq/rseq.smk', unlock=True, dryrun=dryrun, config=config, forceall=force)
        cores = config['cores'][0]
        log_folder = log_folder_all + config['sample_name'][0] + '/'
        os.makedirs(log_folder, exist_ok=True)

        def log_handler(msg):
            # print(msg)
            level = msg["level"]
            error_log = log_folder + "error.log"
            progress_log = log_folder + "progress.log"
            output_log = log_folder + "output.log"
            run_info_log = log_folder + "run_info.log"
            job_info_log = log_folder + "job_info.log"
            job_finished_log = log_folder + "job_finished.log"

            def iter_message(log, message):
                if not os.path.exists(log):
                    json.dump({0: message}, open(log, 'w'))
                else:
                    json_dict = json.load(open(log))
                    max_key = max(json_dict.keys())
                    json_dict[int(max_key) + 1] = message
                    json.dump(json_dict, open(log, 'w'))

            if level == "progress":
                iter_message(progress_log, msg)
            elif level == "output":
                iter_message(output_log, msg)
            elif level == "error":
                iter_message(error_log, msg)
            elif level == "job_info":
                iter_message(job_info_log, msg)
            elif level == "job_finished":
                iter_message(job_finished_log, msg)
            elif level == "info":
                iter_message(run_info_log, msg)

        out = io.StringIO()
        with redirect_stdout(out):
            ret_bool = snk.snakemake('rseq/rseq.smk', force_incomplete=True, dryrun=dryrun, printdag=dag,
                                     config=config, cores=cores, forceall=force, log_handler=[log_handler])
            out = out.getvalue()

            if dryrun:
                out_file = run_path + '/' + config['sample_name'][0] + '/dryrun.log'
            elif dag:
                out_file = run_path + '/' + config['sample_name'][0] + '/dag.gv'
            else:
                out_file = run_path + '/' + config['sample_name'][0] + '/run.log'

            if os.path.exists(out_file):
                os.remove(out_file)

            with open(out_file, 'a') as stdout_log:
                stdout_log.writelines(out)
            if not ret_bool:
                json.dump({'status': 'complete'}, open(log_folder + "/failed.log", 'w'))
                break

        if dag:
            out_file = run_path + '/' + config['sample_name'][0] + '/dag.gv'
            out_svg = run_path + '/' + config['sample_name'][0] + '/dag.gv.svg'
            os.system('cat ' + out_file + ' | dot -Tsvg -o ' + out_svg)

    if not dag and not dryrun:
        json.dump({'status': 'complete'}, open(log_folder + "/completed.log", 'w'))


if __name__ == "__main__":
    print(sys.argv)
    make_snakes(sys.argv[1:-4], sys.argv[-4], sys.argv[-3] == 'True', sys.argv[-2] == 'True', sys.argv[-1] == 'True')
